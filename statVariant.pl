#!/usr/bin/perl -w
use strict;

die("Usage:  perl $0 <sam>  <variant.list> <cutoff> <otPre> <ampliconPos> <refAmplicon.fa> <primer.fa> <iskept: 0=only variant sites,1=all;> <PE: pe=1,S5=0>\n
        Used to stat the number of reads that supported each combinantion of variant on target region;
        This is condunct based on the bam file generated by plugin.
        
        sam: samfile  genenrate by plugin and have been used for call variant with plugin.
        variant.list: variant file generate by plugin based on sam file, many file could be listed as 
                      file1,file2,file3 if you have more than one variant file to be used.
        primer.fa: amplicon primer designed by ionadmin;
        iskept:   if all position or only variant sites of amplicon should be kept;
        PE:       if all were paired end reads sequenced by illumina; if yes, variants nearby reads end
                  will not be discard; default =0(S5,single end reads); 

        Attention: We assign each reads to a amplicon based on where alignment started; but if  start is 
                   no more than 50bp away from the end of amplicon, it will be discarded (see line 46).
                   We stop count the snp if the snp is out of the amplicon region (see line 70 and 112);
        \n") if  @ARGV <7;
print STDERR "length of primer was ignored at  line 265!\n";

my($sam,$varF,$otPre,$ampliconPos,$refAmplicon,$primer,$iskept,$pe) =@ARGV;

my(%h,%posList,%cigList,%alignPos,%variant,%ampliPos,%ampliEnd,%ampliStart,%aid2reads,%hit)=();
my%alleleINpoly=();
my%GoodSite=(); ## used to discarde the site that locate both end of each amplicon; a variant is removed if it is less than 10 bp away from primer.
my%deletePos=();## used to record the 10 site on each end of reads;
$pe=0 unless defined $pe;
&getPos();
&getPloy();
&getAllele();

my($last,$lastChr)=(0,"");
my($min,$max)=(10000000000000,0);

if($sam=~/sam$/){
    open IN, " $sam " or die  "cannot open $sam $!";
}else{
    open IN, " samtools view $sam|" or die "cannot open $sam $!";
}
open OT, "> $otPre.variant_stat.xls" or die  "cannt write $otPre.variant_stat.xls $!"; 
open OR, "> $otPre.outTarget.list" or die  "cannot open $otPre.outTarget.list $!";

print OT "#seqID\talignS\talignEnd\t5'trim:3'trim\tvariant1\tvariant2....
#alignS: the start pos on ref the reads mapped;
#5'trim: if the 5 end of reads was trimed, S=trimed,0=no
#variant: Ref=<it is same as ref in this sit for the reads>, 0=<this reads didnot cover this site>\n\n";
while(<IN>){
    chomp;
    next if /^\@/;
    my($id,$mapFlag,$chr,$pos,$cig,$reads_bak)=(split /\s+/,$_)[0,1,2,3,5,9];
    if($pe==1){ next if ($mapFlag ==0 or $mapFlag==4 or $mapFlag ==16);}
    elsif($pe==0){ next if ($mapFlag!=0 and $mapFlag!=4 and $mapFlag!=16);}else{die"Wrong pe flag $pe\n";}
    next if $chr eq "*";
    print STDERR "$_\n" unless $chr=~/chr/;
    next if length($reads_bak)<100;
    
    unless(exists $ampliPos{$chr}{$pos}){  # out of target Region;
        print OR "$_\n";  
        next;
    }
    my$aid=$ampliPos{$chr}{$pos};
    next if ($ampliEnd{$aid}-$pos)<50;### if no more than 50bp overlapped with amplicon region, this reads may be not derived from this region;
#    $aid2reads{$aid}{$id}=$chr;

    $pos -=1;
    my$pos_2=$pos+1;
    my$reads=$reads_bak; 

    my$md=(split /\s+/, (split /MD:/,$_)[-1])[0];
    $md=(split /\:/,$md)[-1];

    my($trim3,$trim5)=(1,1); 
    my$cigFlag="0:";
    if($cig=~/^(\d+)[SH]/){
        next if $1>=50;
        $cigFlag="S:";
    }else{
        $trim5=0; ## used to check if the varian located in end of reads shoud be discard; if no trim; the mutant in the first/last 10bp will be discarded;
    }

    if($cig=~/(\d+)[SH]$/){
        next if $1>=50;
        $cigFlag.="S";
    }else{
        $cigFlag .="0";
        $trim3=0;
    }

    $aid2reads{$aid}{$id}=$chr;

    $cigList{$id}=$cigFlag;
    $hit{$id}="$chr\t$pos_2\t$aid\t$cigFlag\t$cig\t$md\t$reads_bak";

    my($len,$type,$align)=(0,"",""); ### type belong to {I D M S};
my$cig_=$cig;
    while($cig ne ""){
        last if $pos>$ampliEnd{$aid}; ### prevent that a reads covered two amplicons;

        $cig=~s/^(\d+)(\D+)//;
        ($len,$type)=($1,$2);

        if($type eq "S"){
            $reads=~s/^\w{$len}//;
            next;
        }

        if($type eq "H"){
            $reads=~s/^\w{$len}//;
            next;
        }

        if($type eq "M"){
            $pos +=$len;
            $reads=~/^(\w{$len})(.*)/;
            $align .=$1;
            $reads=$2;
            next;
        }

        if($type eq "I"){
            $reads=~s/^(\w{$len})//;
            $pos +=1;
            $h{$id}{$pos} .= ",insert:$1";
            $posList{$aid}{$pos} ="";
            $pos -=1;
            next;
        }

        if($type eq "D"){
            $align .= "-" x $len;
            $pos +=$len;
            next;
        }

        die("Unknown variant type found for $id: $len,$type,$cig!\n");
    }
#print "##########\n$_\n$id,$chr,$pos,Cig:$cig_  MD:$md\n$reads_bak\n$align\n" if $id eq "QT4GH:02642:04797" ;#exit if $id eq "QT4GH:02642:04797";;
    $alignPos{$id}="$pos_2\t$pos";

    $pos=$pos_2;
    my$start=0;
    my$base="";
    while($md ne ""){
#if($id eq "QT4GH:02642:04797"){ print "md:$md\n";}
        last if $pos>$ampliEnd{$aid}; ### prevent that a reads covered two amplicons;
        if($md =~s/^(\d+)//){
            $pos+=$1;
            $start +=$1;            
            next;
        }
        
        if($md =~s/^\^(\D+)//){
            for(my$kk=0;$kk<length$1;$kk++){
                $pos+=1 if $kk>0;
                $pos+=0 if $kk==0;
                my$deleteBase=substr($1,$kk,1);
                $h{$id}{$pos} .=",delete:$deleteBase";
                $posList{$aid}{$pos}="";
            }
            $pos += 1;
            $start +=length($1);
            next;
        }
        
        if($md =~s/^\D//){
            $base=substr($align,$start,1);
            $h{$id}{$pos}.=",snp:$base";
            $posList{$aid}{$pos} ="";
#if($id eq "QT4GH:02642:04797"){ print "base:$base\t$pos\n";}
            $pos +=1;
            $start+=1;
        }
    }
    
    next if $pe==1;
    ######  just set the type in this reads to be uncovered (mostly occured in partly reads, probably for reads longer than ref.),
    if($trim5==0){
        for(my$kk=$pos_2;$kk<($pos_2+10);$kk++){
            #$h{$id}{$kk} ="a$kk,0";
            delete $h{$id}{$kk};
            $deletePos{$id}{$kk}="";
        }
    }
    if($trim3==0){
        for(my$kk=($pos-9);$kk<=$pos;$kk++){
            #$h{$id}{$kk} ="b$kk,0";
            delete $h{$id}{$kk};
            $deletePos{$id}{$kk}="";
        }
    }
    ######
}

my%kept=();
my%kept2=();
open OH, " >$otPre.reads2haplo.list" or die  "cannt write $otPre.reads2haplo.list $!";
print OH "readsID\thaplotype\tchr\thitPos\tampliconID\ttrim\tcigar\tMD\treadSeq\n";
foreach my$ampliID(keys %posList){
    foreach my$chrPos(sort {$a<=>$b} keys %{$posList{$ampliID}}){
        my$dFlag=0;
        $dFlag=1 if $chrPos<$GoodSite{$ampliID}{"S"};###at least 10bp away from primer is required;
        $dFlag=1 if $chrPos>$GoodSite{$ampliID}{"E"};
        
        my$jj=-5;
        while($jj<=5){
            my$chrPos_=$chrPos+$jj;
            $jj++;
            next unless exists $alleleINpoly{"$ampliID\t$chrPos_"};
            $dFlag=1;# this variant is in poly(ATCG) region or no more than 5bp away from poly.
            last;
        }
        delete $posList{$ampliID}{$chrPos} if $dFlag==1;
    }

    foreach my$rID(keys %{$aid2reads{$ampliID}}){
        my$chr=$aid2reads{$ampliID}{$rID};
        my($otHaplo,$ot)=("","");
        my($alignS,$alignE)=(split /\t+/,$alignPos{$rID})[0,1];
print STDERR "$rID\n" unless exists $alignPos{$rID};

        foreach my$chrPos(sort {$a<=>$b} keys %{$posList{$ampliID}}){
            if($chrPos<$alignS){
                $ot .="$chrPos,0\|";# unless exists $alleleINpoly{"$chr\t$chrPos"};
                $otHaplo.="$chrPos,0|" if exists $variant{"$chr\t$chrPos"};
            }elsif($chrPos>$alignE){
                $ot .="$chrPos,0\|";# unless exists $alleleINpoly{"$chr\t$chrPos"} ;
                $otHaplo.="$chrPos,0|" if exists $variant{"$chr\t$chrPos"};
            }else{
                #unless(exists $alleleINpoly{"$chr\t$chrPos"}){
                    $ot .="$chrPos$h{$rID}{$chrPos}\|" if exists $h{$rID}{$chrPos};
                    if(exists $deletePos{$rID}{$chrPos}){$ot .="$chrPos,0\|";next;#for all partially reads, all variants no more than 10 base away from each end were ignored;
                    }else{$ot .="$chrPos,Ref\|" unless exists $h{$rID}{$chrPos};}
                #}
                if(exists $variant{"$chr\t$chrPos"}){
                    $otHaplo.="$chrPos$h{$rID}{$chrPos}|" if exists $h{$rID}{$chrPos};
                    if(exists $deletePos{$rID}{$chrPos}){$otHaplo .="$chrPos,0\|";#for all partially reads, all variants no more than 10 base away from each end were ignored;
                    }else{$otHaplo.="$chrPos,Ref|" unless exists $h{$rID}{$chrPos};}
                }
            }
        }
        $kept{$ampliID}{$otHaplo}+=1;
        $kept2{$ampliID}{$ot}+=1;
        $otHaplo = "NA" if $otHaplo eq "";
        print OT "$rID\t$ampliID\t$chr\t$alignPos{$rID}\t$ot\n";
        print OH "$rID\t$otHaplo\t$hit{$rID}\n";
    }
}

close IN;
close OT;

open OT, ">  $otPre.varant2genotype.readsNum.xls" or die  "cannt write  $otPre.varant2genotype.readsNum.xls $!"; 
foreach my$key(keys %kept){
    foreach(keys %{$kept{$key}}){
        my$k=$_;
        $k=~s/insert/I/g;
        $k=~s/delete/D/g;
        $k=~s/snp/S/g;
        $k=~s/Ref/R/g;

        print OT "$key\t$kept{$key}{$_}\t$k\n";
    }
}
close OT;

open OT, ">  $otPre.AllVarant2genotype.readsNum.xls" or die  "cannt write  $otPre.AllVarant2genotype.readsNum.xls $!";
foreach my$key(keys %kept2){
    foreach(keys %{$kept2{$key}}){
        my$k=$_;
        $k=~s/insert/I/g;
        $k=~s/delete/D/g;
        $k=~s/snp/S/g;
        $k=~s/Ref/R/g;
        print OT "$key\t$kept2{$key}{$_}\t$k\n";
    }
}
close OT;


sub getAllele{
    my@allVarF=(split /\,/,$varF);
    foreach $varF(@allVarF){

print "$varF\n";
        open IN, " $varF " or die  "cannot open $varF $!";
        <IN>;
        while(<IN>){
            chomp;
            my($chr,$pos,$allele,$aid)=(split /\s+/,$_)[0,1,3,13];
            next if exists $alleleINpoly{"$chr\t$pos"};
            $pos+=1;
            next if exists $alleleINpoly{"$chr\t$pos"};
            $pos+=1;
            next if exists $alleleINpoly{"$chr\t$pos"};
            $pos-=3;
            next if exists $alleleINpoly{"$chr\t$pos"};
            $pos-=1;
            next if exists $alleleINpoly{"$chr\t$pos"};

            $pos+=2;
            $variant{"$chr\t$pos"}="$aid\t$allele";
        }         
        close IN;
    }
}


sub getPos{
    my%Plen=();

    open IN, "$primer" or die  "cannot open $primer $!";
    $/=">";<IN>;
    while(<IN>){
        chomp; 
        my($Pid,$Pseq)=(split /\n+/,$_)[0,1]; 
        $Plen{$Pid} =length $Pseq;
        #$Plen{$Pid} =0;  ###  DONNOT consider the length of primer;
    }
    close IN;
    $/="\n";


    open IN, " $ampliconPos  " or die  "cannot open  $ampliconPos $!";
    <IN>;
    while(<IN>){
        chomp;
        my($aid,$chr,$s,$e)=(split /\s+/,$_);
        $ampliStart{$aid}="$chr\t$s";
        $ampliEnd{$aid}=$e;
        
        for(my$i=$s;$i<=$e;$i++){
            $ampliPos{$chr}{$i}=$aid; 
        }

        $s+=$Plen{"$aid\_F"}; #used to rm variant located in primer;
        $s+=10;               #used to rm variant is less than 10bp away from primer;
        $e-=$Plen{"$aid\_R"};
        $e-=10;
        $GoodSite{$aid}{"S"}=$s;
        $GoodSite{$aid}{"E"}=$e;

        if($iskept ==1){
            for(my$position=$s;$position<=$e;$position ++){
                $posList{$aid}{$position}="";
            }
        }
    }
    close IN;
}


sub getPloy{
 
    open IN, " $refAmplicon " or die "cannto open $refAmplicon $!";
    $/=">";<IN>;
    while(<IN>){
        chomp;
        my($id,@l)=(split /\n+/,$_);
        my$seq= join "",@l;

        die("No pos infor for $id found!") unless exists $ampliStart{$id};
        my%polyPos=();

        foreach my$base(qw/A T C G/){
            my($chr,$start)=(split /\s+/,$ampliStart{$id})[0,1];
            next unless $seq=~/$base{5,}/i;
        
            my$sub=$seq;
            my($befor,$match,$mathcLen)=("","",0);
            while($sub=~/($base{5,})/i){
                ($befor,$match,$sub)=($`,$1,$');
                $start +=length$befor;
                my$polyEnd=$start+(length$match) -1;
                $polyPos{$chr}{$start}=$polyEnd;
                for(my$i=$start;$i<=$polyEnd;$i++){
                    $alleleINpoly{"$chr\t$i"}="";# only record the start and end of polyATCG;
                    $alleleINpoly{"$id\t$i"}=""; #used to selected variant sites based on amplicon ID;
                }
                $start=$polyEnd;
            }
        }
    

        foreach my$Chr(keys %polyPos){
            my($lastEnd,@allStart)=(sort {$a<=>$b} keys %{$polyPos{$Chr}});
            $lastEnd=$polyPos{$Chr}{$lastEnd};
            foreach my$keyP(@allStart){
                next if ($keyP-$lastEnd)>=10;## two ploy(ATCG) is no more than 10 bp away from each other;
                for(my$t=$lastEnd;$t<=$keyP;$t++){
                    $alleleINpoly{"$Chr\t$t"}="";
                }
                $lastEnd=$polyPos{$Chr}{$keyP};
            }
        }
    
        &otherPoly($id,$seq,"A3GA3");
        &otherPoly($id,$seq,"G4AT4");
        &otherPoly($id,$seq,"T6AC5");
        &otherPoly($id,$seq,"T6AT2");
        &otherPoly($id,$seq,"G5TG2");
        &otherPoly($id,$seq,"C2A8");
        &otherPoly($id,$seq,"G2A4");
        &otherPoly($id,$seq,"A2T10");
        &otherPoly($id,$seq,"A3T5");
        &otherPoly($id,$seq,"T5A9");
        &otherPoly($id,$seq,"G3A5");
        &otherPoly($id,$seq,"AGC2A10");
        &otherPoly($id,$seq,"A2TC2A9");
        &otherPoly($id,$seq,"A2GTA4");
        &otherPoly($id,$seq,"T3A2T7");

        &otherPoly($id,$seq,"G4T2G3");#1226;
        &otherPoly($id,$seq,"C1G3C2G4C3G2A3C1A4");#IonCode_0260_rawlib_2 mangjian 2pici;
    }
    close IN;
    $/="\n";
}

sub otherPoly{
    my($ID,$SEQ,$pattern)=@_;
    my($chr,$start)=(split /\s+/,$ampliStart{$ID})[0,1];
    
    my(@base,@num)=();
#    my%polyPos=();
    my$pp="";
    while($pattern ne ""){
        if ($pattern=~s/^(\D)(\d+)//){
            $pp .="$1"."{2,}";
        }elsif($pattern=~s/^(\D)(\D)/$2/){
            $pp .="$1";
        }
    }

    my$sub=$SEQ;
    my($befor,$match)=("","");
    my($total,$count,$pass)=(0,0,1);
    
    if($sub=~/$pp/i){

    while($sub=~/($pp)/i){
        ($total,$count,$pass,$max)=(0,0,1,0);
        ($befor,$match,$sub)=($`,$1,$');
        my$match_=$match;
        
        while($match_ ne ""){
            my$Pnum="";
            if($match_=~s/^(A+)//i){
                $Pnum=$1;
            }elsif($match_=~s/^(T+)//i){
                $Pnum=$1;
            }elsif($match_=~s/^(C+)//i){
                $Pnum=$1;
            }elsif($match_=~s/^(G+)//i){
                $Pnum=$1;
            }

            $Pnum=length$Pnum;
            next if $Pnum<2;
            $max=$Pnum if $max<$Pnum;
            $count++;
            $total+=$Pnum;
        }
        if($count ==2){
            $pass=0 if $total<6;
        }elsif($count==3){
            $pass=0 if $total<12;
        }
        $pass =0 if $max<4;

        $start +=length$befor;
        if($pass==0){
            $start +=(length$match) -1;
            next;
        }

#print "2:\t$ID\t$pp\t$match\t$pass\t$total\t$max\t$otPre\n";

        my$polyEnd=$start+(length$match) -1;
#        $polyPos{$chr}{$start}=$polyEnd; ## set to be comment because only two pure poly should be considered;
        for(my$i=$start;$i<=$polyEnd;$i++){
            $alleleINpoly{"$chr\t$i"}="";# only record the start and end of polyATCG;
        }
        $start=$polyEnd;
        last  unless $sub=~/$pp/i;
    }
}
}

